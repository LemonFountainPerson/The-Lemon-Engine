The LemonEngine
Liam Fuentes Pessoa
_________________________________________________


This engine uses the C standard library, stb_image.h for PNG loading, and SDL3 for window, audio and input proccessing. 
Everything else is done "in-house" with an emphasis in readability, reusability and performance.


**Getting Started**

The core of all data structures for the engine is contained within data.h. In it, all structs, enums and macros are defined, as well as including every other external/standard library the engine requires. Every file that comprises the engine includes this file, and it does so by checking if "IS_DEFINED" is defined to guard against redefinitions. The main of the engine is LemonMain.c, and should be the starting point of any actions performed in the engine. (NOTE: In the current version, a seperate windows_main.c file is used as the main of the engine to replace the function "RunLemonEngine" conatined within LemonMain. This is done for stability reasons and in the future "RunLemonEngine" will used as the starting point.)

The main of the engine is relatively simple, comprising 3 sections: engine initialisation of relevant structs, audio devices and the window, the main game loop, and engine quit functions with data cleanup.
The overall engine works mostly of a single struct called the GameWorld. The GameWorld contains pointers to all relevent allocated data for the game scene to run, such as the player if it exists, backgrounds, the object list, etc. 

# Struct definition:
struct world
{
	struct objectController *objectList;
	int drawnObjects;

	struct playerData *Player;

	struct spriteSet *BackGrounds;
	struct sprite *bgSpriteBuffer;

	double bgParallax;
	int bgTileVertically;
	int bgParallaxChunkSize;
	double bgChunkParallax;

	int cameraX;
	int cameraY;
	int level;
	double Gravity;

	int drawHitboxes;
	int drawSprites;
	int drawBackGround;
	int drawPlayer;
	int playBgMusic;
};


The GameWorld may be passed in to various functions to perform game actions, although most of the time functions will only take the neccessary data to perform its task. The player is represented as another allocated struct, and is accessible via the main function or as a pointer from the GameWorld. While the engine has a player controller already created, depending on the needs of a game, the player can be swapped out with minimal changes to surrounding code. Only its struct in data.h and the playerController.c files themselves need to be updated to function.

# Struct Definition:
struct playerData
{
	int xPos;
	int xPosRight;
	int yPos;
	int yPosTop;
	double yVelocity;
	double xVelocity;
	double maxYVel;
	double maxXVel;

	int inAir;
	int jumpHeld;
	int jumpProgress;
	int crouch;

	double PhysicsXVelocity;
	double PhysicsYVelocity;
	double direction;

	int xFlip;
	int currentSprite;
	struct sprite *spriteBuffer;

	int spriteCount;
	struct spriteSet *spriteSetPtr;

	enum Layer playerLayer;

	int coinCount;
};


The screen of the engine is comprised of a struct called a RenderFrame that contains a pointer to the Uint32_t pixel data of the frame, and the screen's intended width and height. This frame is used by the drawing routines as a buffer to render all items for the game's scene. This frame is then taken by the window renderer (windows API for windows_main) and displayed to the window.


**Main game loop**

For ease of use, it is unrecommended to alter the main game loop code already present. However if you wish to do so, keep in mind the following information.

# Initialisation
After window and audio initialisation, game data is created using the initialiseWorld and initialisePlayer functions. These functions take in a PlayerData struct and a World struct respectively. They are formatted so that pointer association between the GameWorld and the Player is handled automatically, and these functions can be called in any order, and will accept NULL if the respective struct has not been created/initialised yet. The functions each return a pointer to allocated data for their respective structs. 

Most functions in the engine at the higher levels will perform checks to insure the pointers being passed to them are valid, however at lower levels of engine operation this may not be the case, so it is unadvised to call smaller functions such as helper functions directly without first ensuring Player and GameWorld initialisation.

# Game Loop
The main structure of the game loop is as follows: 
First, updatePlayer is ran to take user input and operate the player. 

Next, updateObjects is run to update every object in the GameWorld. 
After these two functions all game logic has been performed. Any further functionality should go here after these functions (such as menu control, other self-implemented object types, etc.)

Next, worldCameraControl is called to move the GameWorld's camera according to the state of the GameWorld. (i.e: following the player) The seperation of the camera and the player means the camera is completely independent of the player and can be moved independently if you wish. For convinience, it's recommended to do this from the worldCameraControl function.

# Rendering
Next, rendering begins. First, cleanRenderer is called to reset the frame for new things to be drawn, as well as NULL handling in the event of mis-allocated memory. 

Objects in the GameWorld are drawn in the order they are placed within the linked list that comprises all objects. (except the player) In order to facilitate better control, there is a layering system in which an object can be defined to only be drawn on a specific layer, and the main game loop does one rendering pass for each of these layers. This means objects in the FOREGROUND will always be drawn over objects in the MIDDLEGROUND and BACKGROUND, and so on. 
By default, the player is drawn on the MIDDLEGROUND layer, however due to the player not being an object contained within the GameWorld's object list, it is always drawn after the objects of that layer have been drawn. (For example, on the MIDDLEGROUND the player will be drawn behind the objects on the FOREGROUND but always in front of the objects on the MIDDLEGROUND and BACKGROUND)
More layers can be defined in the Layers enum contained within data.h, but additional rendering passes must be implemented within the main game loop to account for this.

After the RenderFrame's screen buffer has finished being rendered for the frame, PutScreenOnWindow is run to well...you know. This is function that simply comprises of some SDL functions responsible for creating a surface, a texture fo=rom that surface and finally rendering the texture to the renderer to be placed on the window. (This function is replaced by two windows API functions in windows_main.)

# Audio
Next, the iterateAudio function is called to handle audio events. SDL handles audio multi-threadedly so this function is mostly used to repeat sounds playing on looping channels, but can also be used to apply other sound modifications to the engine's audio. The LemonEngine uses SDL's BindAudioToStream function to effectively create a channel of audio that plays asyncroniously and can play multiple sounds at once. 

However, the engine uses multiple channels for a few reasons: multiple sounds playing on a channel means that only the most recently played sound can be accessed via SDL such as for stopping audio or repeating it. There is no (easy) way to distinguish between sounds you would like to repeat and those you do not. It also helps with organisation to seperate different channels for different purposes, especially if problems arise. For these reasons and more, there are multiple channels created as defined by the CHANNEL_COUNT macro in data.h.

The LOOP_CHANNELS macro also defines how many of those channels are channels where only one sound is played at a time and looped. It defines the first (LOOP_CHANNELS) channels as being these such channels. For example, by default there are 8 total channels created, and 4 Loop-Channels. This means channels 0-3 comprise channels where sounds will repeat and only one at a time will play, while channels 4-7 are regular, not repeating channels.
For ease of operation, macros or enums can be defined to assist with organisation, such as defining "MUSIC_CHANNEL" as 0 to signify that channel 0 is reserved for music.

# Frame Throttling
Next, the frame throttling functionality. The function frameRate is called with an integer to determine how much to delay to maintain the specified frames per second. Ideally, without this function the engine will run unencumbered at approximately 400-600 fps. (NOTE: while partially implemented, deltaTime calculations and the frameRate function are not 100% accurate and are currently being worked on for a future version. As such, this information and its functionality may be subject to change.)

# Extra Stuff
After that, the frame has finished rendering and the remaining space in the main game loop can be used for other features, such as debug functions, some of which are already present, or anything else. If any new feature requires interaction or rendering, its recommended to format them as simple function calls and to place them prior to the frame throttling code.

The variable "gameRunning" is a global variable which is used by the game loop to decide when to terminate the engine program. When gameRunning equals 0, the game loop ends and clean-up begins.


**Game Objects**

As previously mentioned, all objects in a game scene other than the player are comprised of an allocated Object struct that is part of a linked list set pointed to via GameWorld->ObjectList->firstObject .... etc. While the player is the user's way of interacting with the game world, objects are the building blocks of that world and as such are the main way of adding content to the game engine. Loading a level from an external .Lem file (currently actually .txt) is essentially just a long list of definitions for objects.